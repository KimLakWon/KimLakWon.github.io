---
title: "네트워크 개념 정리"
date: 2019-05-21 02:48:28 -0400
categories: jekyll update
---

네트워크

1. 컴퓨터 네트워크와 인터넷

 1) 인터넷이란 무엇일까?

  - 통신링크(물리적케이블) + 패킷스위치 = 경로(Route, Path)
  - 종단시스템(호스트, 컴퓨팅 장치)은 ISP(Internet Service Provider)를 통해 인터넷에 접속한다.
  - ISP도 계층이 있는데 상위 계층은 광 링크에 고속 라우터로 구성되고 따로 관리되고 다른 주소배정 방식을 따른다.
  - 모든 구성요소들은 프로토콜을 수행한다. 이것은 곧 상호 호환을 위한 어떤 규칙을 지킨다는 의미이다.
  - 인터넷은 모두 IETF에서 개발한 표준 문서인 RFC를 따른다. (TCP/IP, HTTP, SMTP 등 7000개가 넘는 항목이 있음)
  - IEEE 802는 이더넷과 무선 WiFi 표준을 기술하고 있다.
  - 인터넷 : 종단 시스템끼리 ISP라는 패킷스위치와 통신 링크로 이루어진 경로를 통해 해당 프로토콜을 수행하며 데이터를 전송하는 것.
  - 통신하는 둘 이상의 원격 개체가 포함된 인터넷에서의 모든 활동은 프로토콜이 제어한다.

 2) 네트워크의 가장자리(Edge)

  - 호스트는 클라이언트와 서버 모두를 지칭한다.
  - 가정접속은 DSL, 케이블 TV 서비스, FTTH, 위성링크로 나눌 수 있다.
  - (1) DSL(Digital Subscriber Line) : 가장 널리 보급되어 있다. 가정에서 전화나 인터넷 데이터가 DSL 모델로 흘러들어간다.
  - 그 뒤에 기존전화선을 따라 DSLAM으로 전달된다. DSLAM은 Telco(SKT,KT,LG)의 지역 중앙국을 의미한다.
  - 당연히 아날로그 -> 디지털로 변환되고, 다운로드가 업로드보다 빠른 비대칭 접속이다.
  - (2) 케이블 TV 서비스 : 이더넷 포트에서 모뎀과 케이블을 지나 CMTS라는 중앙국으로 간다.
  - 동시 수신자가 많을수록 다운스트림 전송률은 작아진다.
  - (3) FTTH(Fiber To The Home) : 직접 광섬유 경로로 빠른 속도를 제공하는 미래 기술 (초고속 인터넷)
  - (4) 위성링크 : 케이블이 가기 어려운 시골지역에 주로 사용한다.
  - FTTH(20Mbps) > 케이블TV(13Mbps) > DSL(5Mbps) > 위성링크 (1Mbps)
  - 기업 접속은 이더넷과 와이파이를 이용한다.
  - 유선 LAN은 이더넷인데, 보통 100Mbps~1Gbps이고 서버는 10Gbps까지 가기도 한다.
  - 무선 LAN은 와이파이인데, 요즘은 거의 모든 곳에 AP(Access Point)가 있어 오늘날은 100Mbps를 넘는다.
  - 요즘은 와이파이가 홈 네트워크에서도 많이 사용된다.
  - 광역 무선 접속은 3G와 LTE가 있는데, WIFI는 수십미터마다 AP가 있어야하지만, 이것은 수십킬로미터 반경에만 있으면 된다.
  - 요즘은 5G가 나왔다.
  - 물리 매체는 '꼬임 쌍선', '동축 케이블', '광섬유', '지상 라디오 채널', '위성 라디오 채널'이 있다.
  - 꼬임쌍선 : 2개의 구리선으로 가장 싸고 많이 사용한다. 전화는 99%, LAN은 UTP를 사용.
  - 동축케이블 : 2개의 구리선으로 동심원 형태이고 유도 공유 매체이다. 주로 케이블 TV에 사용.
  - 광섬유 : 가늘고 유연한 매체로 광역 유도 전송 매체로 비싸서 가정에서는 사용하지 않고, 주로 해저 링크나 광역 전화 네트워크에 사용한다.
  - 지상 라디오 채널 : 전자기 스펙트럼을 이용하여 먼거리 신호가 가능하지만 주변 환경의 영향을 많이 받는다.
  - 위성 라디오 채널 : 미래 기술로 수Gps의 속도를 가진다.

 3) 네트워크 코어
  - 저장-후-전달 : 패킷은 스위치가 패킷의 전체를 받아야 전송된다.
  - 종단간 지연 : 링크의 개수 X 비트의 수 / 전송속도
  - 패킷 스위치는 도착한 패킷을 대기시키기 위한 출력 버퍼(큐)를 갖고 있다.
  - 큐잉 지연 : 출력 버퍼에서 자신이 선택되기를 기다리는 시간
  - 패킷 손실 : 출력 버퍼에 패킷이 꽉 차있다면, 그 다음에 도착한 패킷들은 드랍해야 한다.
  - 전달 테이블 : 라우터에는 패킷의 목적지(IP)를 찾기 위한 전달 테이블이 저장되어있다.
  - 라우팅 프로토콜 : 자동으로 전달 테이블을 설정하기 위해 이용되는 프로토콜 (ex. 최단경로설정)
  - 회선 교환 : 경로상에 필요한 자원(버퍼, 링크 전송률)을 통신 세션 동안 예약함으로써 대기 없이 바로 연결 가능. (ex. 전화망)
  - 패킷 교환 : 미리 예약하지는 않지만 사실상 지연이 거의 없고 사용자 수가 3배가 넘게 이용가능하기에 주로 패킷교환
  - 주파수 분할 다중화(FDM) : 주파수 대역을 고정적으로 제공한다 (ex. 라디오 : 88~108MHz)
  - 시 분할 다중화(TDM) : 고정된 시간 슬롯으로 쪼개가며 제공한다.
  - 회선 교환은 비활용 기간이 많아 낭비가 심하고, 대역폭을 보존하는 것은 복잡한 소프트웨어 기술을 필요로 한다.
  - 세계 모든 ISP끼리도 서로 연결해야한다. (네트워크의 네트워크)
  - 현재의 네트워크 구조 : 지방-도시-국가 ISP + Pop + 멀티홈 + peer + IXP + 콘텐츠-제공자 네트워크

 4) 패킷 교환 네트워크에서의 지연, 손실과 처리율
  - 지연의 종류에는 '처리 지연', '큐잉 지연', '전송 지연', '전파 지연'이 있다.
  - (1) 처리 지연(Processing Delay) : 패킷 헤더를 조사하고 어디로 보낼지 결정하고 링크 앞의 큐로 배분하는 시간 (msec)
  - (2) 큐잉 지연(Queuing Delay) : 앞서 도착한 패킷의 수에 따라 큐에서 기다리는 시간 (microsec ~ msec)
  - (3) 전송 지연(Transmission Delay) : 링크 전송률에 따라 결정된다. 패킷의 모든 비트를 링크로 밀어내는데 필요한 시간 (microsec ~ msec)
  - (4) 전파 지연(Propagation Dealy) : 링크의 처음부터 라우터까지의 전파에 필요한 시간으로 물리 매체마다 다르다. (sec)
  - 고속도로라고 비유했을 때, 전송 지연은 '요금소'에서 요금을 계산하는 시간, 전파 지연은 '고속도로'에서 달리는 시간이다.
  - 만약 전송 지연 > 전파 지연일 경우, 시간이 지날수록 점점 트래픽이 늘어나 제기능을 못 할 것이다.
  - 트래픽 강도가 1보다 크지 않게 설계해야한다. 1보다 크다면 큐잉 지연은 무한대로 발산한다. 
  - 트래픽 강도가 1보다 작다면, 패킷이 주기적으로 도착한다면 큐잉 지연은 존재하지 않고, 패킷이 몰려서 도착할 때만 큐잉 지연이 발생한다.
  - 실제로 큐는 유한 용량을 가지므로, 큐가 꽉차면 패킷을 저장할 수 없고 버리게 된다.
  - 패킷화 지연 : 프로토콜이 의도적으로 전송을 지연시키는 경우 (ex. VoIP에서 패킷을 전송하기 전에 디지털 음성으로 인코드하고 보내야 한다.)
  - 처리율 : 정보를 주고 받는 두 개의 종단 시스템의 최소 전송률(병목 링크의 전송률) (ex. 클라 20bps, 서버 40bps면 처리율은 20bps로 해야 됨)
  - 네트워크 코어는 보통 전송률이 아주 높으므로, 주로 접근 네트워크의 성능에 따라 결정된다.
  - 다만, 수많은 동시 다운로드가 발생 될 경우 네트워크 코어가 1/N으로 전송속도가 감소되므로 이 때는 네트워크 코어의 성능에 좌우된다.

 5) 프로토콜 계층과 서비스 모델
  - 프로토콜 계층화 : 복잡한 시스템의 잘 정의된 특정 부분을 논의할 수 있게끔 단순화 해주는 것
  - 프로토콜 스택(Top-Down) : 애플리케이션 - 트랜스포트 - 네트워크 - 링크 - 물리
  - OSI(Open System Interconnection) 모델 : 프레젠테이션 - 세션이 추가 된다. (물데네전세표응)
  - 패킷은 이동하는 과정에서 점점 캡슐화 된다 (메시지 - 세그멘트 - 데이터그램 - 프레임)
  - 헤더 필드 : 그 계층에서 추가된 패킷
  - 페이로드 필드 : 상위 계층에서 전달된 패킷

2. 애플리케이션 계층

 1) 네트워크 애플리케이션의 원리
  - 네트워크 구조는 고정되어 있고, 애플리케이션 구조는 'CS 구조'와 'P2P 구조'가 있다.
  - (1) 클라이언트 - 서버 구조 (CS 구조) : 클라이언트가 항상 켜져있는 서버로 서비스 객체를 요청함. (ex. 웹, 파일 전송, 원격 로그인, 전자메일, SNS 등)
  - (2) Peer - To - Peer (P2P 구조) : 서버에 최소로 의존하고 피어끼리 통신, 보안, 성능에 문제점. (ex. 토렌트, 스카이프, 다운로드 가속기)
  - (3) 하이브리드 구조 : CS 구조 + P2P 구조
  - 클라이언트는 통신 세션에서 통신을 초기화하는 프로세스고, 서버는 세션을 시작하기 위해서 접속을 기다리는 프로세스이다..
  - 프로세스는 소켓을 통해 네트워크로 메시지를 주고받는다. (ex. 프로세스 - 집, 소켓 - 출입문)
  - 소켓 : 호스트의 애플리케이션 계층과 트랜스포트 계층 간의 인터페이스
  - 프로세스에는 IP주소와 수신 소켓을 명시하는 식별자(포트번호)를 포함해야 한다. 
  - 호스트는 많은 네트워크 응용 프로그램을 동시에 수행할 수 있기 때문에 번호를 부여함. 이미 정해져 있는 번호도 있음. (ex. 웹 : 80, 메일 : 25)
  - 트랜스포트 계층은 여러 프로토콜을 제공하고, 애플리케이션 개발자는 적합한 서비스를 선택하면 된다.
  - 적합한 서비스 고르는 4가지 요소.
  - (1) 신뢰적 데이터 전송 : 은행은 중요함, 오디오/비디오는 안중요함.
  - (2) 일정한 처리량 : 전화,멀티미디어는 중요함, 메일, 파일전송은 안중요함.
  - (3) 시간 보장 : 실시간 애플리케이션(VR, 멀티게임, 원격 등)에는 중요함, 비실시간은 안중요함.
  - (4) 보안 : 다 중요함;;
  - 인터넷은 애플리케이션에게 2가지의 전송 프로토콜을 제공한다.
  - (1) TCP 서비스 : 연결 지향형(3핸드셰이크), 신뢰적, 혼잡제어, SSL 제공
  - (2) UDP 서비스 : 비연결형, 비신뢰적, 혼잡제어X, 간단함, 빠름.
  - 인터넷 전화는 UDP가 더 좋지만, 방화벽과 같은 이유로 TCP로 설계하는 경우도 많다.
  - 애플리케이션 계층 프로토콜 : 교환 메세지 타입,필드의 정보, 언제 어떻게 전송 등을 정의
  - 개방 애플리케이션 계층 프로토콜 : RFC에 명시 (ex. 웹 HTTP, 전자메일 SMTP, 파일전송 FTP)
  - 비개방 애플리케이션 계층 프로토콜 : 독점 (ex. 스카이프)

 2) 웹과 HTTP
  - 웹 : 1990년대 이후 등장하여, 사용자가 원할 때 원하는 것을 수신하는 on-demand 방식
  - 웹 브라우저와 웹 서버가 서로 HTTP 메세지를 주고 받는다.
  - HTTP는 TCP를 전송 프로토콜로 사용하고, 전에 했던 서비스를 기억하지 않는 비상태(Stateless) 프로토콜이다.
  - RTT(Round Trip Time) : 패킷이 클라이언트 - 서버 - 클라이언트 까지 걸리는 시간
  - 세방향 핸드셰이크 : 클라이언트에서 서버로 보내고, 서버에서 다시 클라이언트로 보내는 것.
  - HTTP는 비지속 연결과 지속 연결(디폴트)이 있다.
  - (1) 비지속 연결 : 연결요청 단계와 전송요청 단계가 다른 TCP 연결로 이루어진다. (걸리는 시간 : 객체마다 2RTT + 파일 수신 시간)
  - (2) 지속 연결 : 같은 TCP 연결로 이루어진다. 파이프라이닝을 이용해 빠르다. (걸리는 시간 : 총 3RTT + 파일 수신 시간 )
  - HTTP 메시지 포맷은 ASCII 텍스트로 쓰여있고, 요청 메세지는 5줄, 응답 메세지는 7줄+α로 되어있다.
  - 요청 메세지 : 1줄(요청라인) : <방식> <URL> <HTTP 버전>, 2줄 : Host 명시, 3줄 : 지속/비지속 연결, 4줄 : 웹브라우저, 5줄 : 콘텐츠 협상 헤더
  - HTTP 요청 방식은 5가지가 있다.
  - (1) POST : 검색엔진처럼, 클라이언트가 입력한 어떤 정보를 몸체에 포함하여 보내는 방식
  - (2) GET : 입력한 정보를 URL 뒤에 넣어서 보냄. (HTML은 보통 GET을 주로 사용)
  - (3) HEAD : 요청 객체는 보내지 않음. (주로 디버깅)
  - (4) PUT : 웹 서버에 업로드할 객체(ex. 파일)를 필요로하는 것에 사용.
  - (5) DELETE : 웹 서버에 있는 객체를 지우는 것을 허용.
  - 응답 메세지 : 상태라인 : <HTTP 버전> <상태 코드> <해당 상태 메시지>
  - 헤더라인 : 1줄 : 지속/비지속, 2줄 : 시간, 3줄 : 웹서버, 4줄 : 최근 수정 시간, 5줄 : 객체 바이트 수, 6줄 : 타입
  - 상태코드는 5가지가 있다.
  - (1) 200 OK : 요청이 성공되었고, 정보가 응답으로 보내졌다.
  - (2) 301 Moved Permanently : 요청 객체가 이동되었음. 자동으로 새로운 URL 추출함.
  - (3) 400 Bad Request : 서버가 요청을 이해할 수 없는 이상한 오류 코드
  - (4) 404 Not Found : 요청 문서가 서버에 존재하지 않음.
  - (5) 505 HTTP Version Not Supoted : 요청 HTTP 프로토콜 버전을 서버가 지원하지 않음.
  - HTTP는 Stateless기 때문에 수천개의 TCP를 연결할 수 있지만, 접속 제한 또는 컨텐츠 전송 등은 쿠키를 이용할 수 있다.
  - 서버는 처음 방문한 클라이언트에게 쿠키 헤더를 포함하여 응답 메세지를 보낸 뒤, 백엔드 DB에 저장하고, 나중에 또 왔을 때 그 정보를 기반으로 추천한다.
  - 쿠키는 사생활 침해로 이어질 수 있는 논란이 있다.
  - 웹 캐시 : 프록시 서버라고도 하며, 웹 서버를 대신해 HTTP 요청 메세지를 처리해주는 네트워크 개체
  - 먼저 웹 캐시에 있는지 확인 후 없으면 웹 캐시가 웹 서버에서 객체를 가져와서 제공해준다. (중개자 역할)
  - 웹 캐시는 서버이면서 클라이언트이고, ISP가 구입하고 설치한다.
  - 웹 캐시의 장점 : 응답 시간 감소, 웹 트래픽 대폭 감소
  - CDN의 발달로 인해, 웹 캐시가 점점 중요해지고 있다.
  - 웹 캐시의 문제점 : 실제 서버가 업데이트 되었다면, 캐시에 있던 자료들은 잘못된 정보임.
  - 조건부 Get( 해결책 ) : 최근 수정 날짜를 헤더에 포함해서 비교한다. (같다면 304 Not Modified)

 3) 인터넷 전자메일 (SKIP;;)

 4) DNS (인터넷의 디렉토리 서비스)
  - DNS : 필요에 따라 호스트네임과 IP주소를 변환해주는 프로토콜 
  - 호스트네임은 사람이 식별하기 좋고, IP주소는 컴퓨터가 식별하기 좋다. (고정길이 숫자이므로)
  - DNS 서버는 BIND 소프트웨어를 수행하는 유닉스 컴퓨터이고
  - DNS는 UDP 상에서 수행되고, 포트번호 53이다.
  - URL에서 도메인을 입력했을 때 DNS 서버를 거쳐야하는데 가까운 DNS 서버에 캐시되어있으므로 그리 오래걸리지 않는다.
  - DNS는 변환 말고도 여러가지 추가 서비스를 제공한다.
  - (1) 호스트 엘리어싱 : 여러개의 별명을 가질 수 있도록 허락한다.
  - (2) 메일 서버 엘리어싱 : 전자메일 주소는 기억하기 쉬운 것이 좋다.
  - (3) 부하 분산 : 인기 있는 사이트는 여러 서버에서 다른 IP주소로 실행되므로, 트래픽을 분산시킨다.
  - DNS는 다른 애플리케이션 프로토콜과 다르게 사용자와 직접 상호작용하지 않는 프로토콜이다.
  - DNS가 하나의 중앙 서버라면, 서버가 고장났을 때나 트래픽의 과도한 양이나, 유지관리 문제들이 있을 수 있다.
  - 그래서 3계층으로 나눈다. 루트 DNS서버, TLD(최상위 레벨 도메인) DNS 서버 - 책임 DNS 서버
  - (1) 루트 DNS 서버 : 전세계에 400개 정도, 거의 북미, 우리나라는 몇 대 없다.
  - (2) TLD DNS 서버 : com, org 나 kr, uk 같은 상위 레벨 도메인들.
  - (3) 책임 DNS 서버 : 웹서버를 가진 모든 기관은 공개적으로 DNS 레코드를 책임 DNS 서버에 제공해야한다.
  - (4) 로컬 DNS 서버 : 항상 우리의 '가까이'에 있다. ISP들은 로컬 DNS 서버를 갖고 있다.
  - 주로 호스트-로컬만 재귀적이고, 나머지는 반복적 질의이다.
  - DNS 캐싱 : 로컬 DNS 서버가 메모리가 있어서, IP를 바로 제공 가능 (2일 정도 뒤 삭제)
  - DNS의 취약점으로는 3가지가 있다.
  - (1) DDos : 다량의 패킷을 DNS 루트 서버로 보내서 정상적인 DNS 질의들이 응답받지 못하게 하는 것.
  - 요즘은 서버를 블록해서 필터를 하지만, TLD로 공격하는 방법은 막기 힘듬..
  - (2) 중간자 공격 : 질의를 가로채어 가짜 응답 리턴. 이상한 웹사이트로 유도 (ex. DNS Poisoning)
  - (3) 목표 호스트 공격 : 위장 출발지 주소를 가진 DNS 질의를 서버에 보내서 그들이 원하는 목표 호스트에 응답이 가도록 한다. (아직 성공을 못했다고?)

 5) P2P 파일 분배
  - P2P 구조는 간헐적으로 연결되는 호스트 쌍들이 직접 통신한다.
  - 수신자가 다른 피어에게 재분배하므로 서버의 분배 프로세스를 도울 수 있다.
  - CS 구조는 클라이언트가 1000배 늘면, 전송시간도 1000배 늘지만, P2P는 그보다 적게 늘어난다. 아무튼 좋다.
  - 분배가 시작되면 서버만이 파일을 갖고 있다.
  - 토렌트 : 특정 파일의 분배에 참여하는 모든 피어들의 모임
  - 토렌트에 가입하면 트랙커라는 노드에 자신의 IP를 등록하고, 주기적으로 자신이 있음을 알린다.
  - 나중에 어떤 애가 파일을 달라고 하면 TCP 연결을 통해서 청크(256Kbyte정도)를 주고받는다.
  - 퍼즐조각 끼워 맞추듯 파일을 전송하고, 거의 1명이 50명에게서 청크를 받아온다.
  - 청크는 가장 희귀한 것부터 맞추고, 가장 빠르게 전송하는 이웃에게 먼저 요청한다.
  - 요청 받은 이웃은 청크를 보내고, 본인은 '활성화'가 되는 보상을 얻게 된다. (TFT 보상방식)

 6) 비디오 스트리밍과 컨텐츠 분배 네트워크(CDN)
  - 인터넷 비디오 : 비디오를 스트리밍 하기 위해서는, 서버에게 온디맨드 방식으로 요청한다. 비트 전송률이 높을수록 이미지 품질이 높아진다.
  - 사용자의 인터넷 속도에 따라 여러 버전으로 압축할 수 있다.
  - HTTP 스트리밍 : URL에 TCP 연결을 해서 GET으로 요청하면, HTTP 응답 메세지에 파일을 전송해서 보내준다. (ex. 유튜브)
  - 하지만, 클라이언트들은 모두 성능이 다른데 똑같이 전송받는다는 것이 문제가 될 수 있다.
  - DASH : 각 비디오는 여러개의 품질 버전을 갖고 있고, 몇초단위로 조사하여 가용 대역폭이 높으면 좋은 품질의 동영상을, 가용 대역폭이 낮으면 나쁜 품질의 동영상을 보낸다.
  - 그래서 우리가 유튜브를 볼 때, 인터넷이 불안정하면 화질이 나빠졌다가 좋아졌다가 하는 것이다.
  - CDN은 모든 대륙에 인기 있는 비디오를 효과적으로 반복 전송하기 위해서 데이터 복사본들을 분산 서버에 저장하는 방식이다.
  - 유튜브는 구글의 사설 CDN을 통해 분배된다.
  - CDN의 상반되는 철학은 2가지가 있다고 볼 수 있다.
  - (1) Enter Deep : ISP 깊숙히 들어가 지연시간 및 처리율 향상. 하지만 관리 비용 커짐 (ex. Akamai)
  - (2) Bring Home : 핵심 지역 인터넷 교환지점(IXP)에 배치하여 관리 비용은 줄지만, 지연시간 및 처리율 하락 (ex. Limelight)
  - 자주 요청되지 않는 비디오는 CDN 캐시에서 삭제된다.
  - 7가지 CDN 동작과정 : 집 -> 로컬 DNS -> 책임 DNS -> 로컬 DNS -> CDN -> 로컬 DNS -> 집 -> 동영상 제공하는 서버
  - 클러스터 선택 정책 : 지리적으로 가까운 CDN or 실시간으로 핑을 날려서 가까운 CDN

3. 트랜스포트 계층

 1) 트랜스포트 계층 서비스 및 개요
  - 트랜스포트 계층 프로토콜은 프로세스들 간의 논리적 통신을 제공한다. ( 사촌형제들 끼리 )
  - 네트워크 계층 프로토콜은 호스트들 간의 논리적 통신을 제공한다.  ( 집 끼리 )
  - 즉, 형제(프로세스)들의 편지(데이터)를 모아서 우편함(큐)에 집어넣는 일과 우편함에서 우편들을 꺼내서 형제들에게 나눠주는 일을 한다.
  - 여기서는 데이터에 헤더를 붙여서 세그먼트를 만듦.
  - TCP/UDP : 트랜스포트 계층 프로토콜로써 프로세스끼리 전달할 수 있도록 다중화, 역다중화를 지원하고, 무결성을 검사해준다.

 2) 다중화와 역다중화
  - 역다중화 : 세그먼트가 왔을 때, 올바른 소켓으로 전달하는 것
  - 다중화 : 올바른 소켓으로 전달하도록 세그먼트를 만들어서 보내는 것
  - 역다중화와 다중화를 위해서 포트번호를 사용한다. (0~65535이고, 0~1023은 사용 제한)
  - UDP 다중화와 역다중화 : 목적지 포트/IP만으로 세그먼트를 식별, 출발지 포트는 복귀할 때 사용.
  - TCP 다중화와 역다중화 : 목적지 포트/IP와 출발지 포트/IP로 세그먼트를 식별
  - UDP는 출발지 IP를 모르기 때문에, 출발지가 식별이 안될 수도 있다. (피씨방에서 다른 애들 목소리가 들리는 이유)
  - 요즘 웹서버는 하나의 프로세스만 사용한다.

 3) 비연결형 트랜스포트 : UDP
  - 다중화/역다중화 + 간단한 오류 검사 기능을 제공한다.
  - 핸드셰이크는 사용하지 않는다.
  - DNS, 멀티미디어, 실시간 앱, SNMP(네트워크 관리) 등
  - 지연을 원치 않거나, 손실은 허용되거나, 오버헤드없이 빠르게, 많은 클라이언트 수용 하고 싶을 때 사용한다.
  - 단점 : 혼잡제어가 없어서 네트워크 폭주 상태에 빠질 수 있다. (TCP 사용자들까지 피해본다)
  - UDP 체크섬 : 2바이트로 세그먼트 오류를 검사한다. 16비트를 모두 더하고 오버플로우 일어났으면 1을 더한다.
  - 1의 보수를 취하고 보낸뒤 수신자꺼랑 더한 뒤 11111..이 안되고 0이 있으면 오류이다.
  - 오류를 발견하면, 그냥 버리거나 경고를 하고 넘긴다.

 4) 신뢰성 있는 데이터 전송의 원리

 5) 연결지향형 트랜스포트 : TCP

 6) 혼잡제어의 원리

 7) TCP 혼잡제어


4. 네트워크 계층

 1) 네트워크 계층 개요
  - 네트워크 계층에서는 세그먼트에 헤더를 더해 데이터 그램을 만들어서 라우터로 넘긴다.
  - 라우터는 트랜스포트/애플리케이션 계층이 없다.
  - 라우터는 '포워딩'과 '라우팅' 기능을 가지고 있다.
  - 포워딩 : 경로 상에 다음 라우터로 전달하는 것. 데이터 영역에서 실행. 매우 짧은 시간. 하드웨어 실행. 로컬 포워드 테이블 존재.
  - ex. 여행 중에 운전자가 교차로 하나를 선택하는 과정
  - 라우팅 : 전체 패킷 경로를 설정하는 라우팅 알고리즘. 제어영역에서 실행. 긴 시간. 소프트웨어 실행.
  - ex. 여행 중에 운전자가 전체 경로를 선택하는 과정
  - 라우팅 알고리즘은 포워딩 테이블의 내용을 결정한다. (네트워크 운영자가 결정하는게 아님;;)
  - 또는 원격 컨트롤러 SDN을 두어서 각 라우터와 상호작용하여 포워딩 테이블의 값을 결정해준다.
  - ATM 네트워크 모델 : 전달 보장, 전달 속도 보장, 순서 보장, 대역폭 보장, 보안 서비스 모두 제공!
  - 최선형 서비스 모델 : 아무것도 제공 X
  - 하지만, 최선형 서비스 모델이 주로 사용된다. (?)
  - 패킷 스위치 : 링크 계층 스위치(L2) + 라우터(L3)

 2) 라우터 내부에는 무엇이 있을까?
  - 4가지 요소 : 입력 포트 + 스위칭 구조 + 출력 포트 + 라우팅 프로세서(CPU,소프트웨어)
  - 32Bit IP의 경우 40억개의 엔트리를 모두 테이블에 구현하는것이 아니라
  - 범위를 나눠서 각각의 prefix를 대응시켜 해당 링크 인터페이스로 이동시킨다.
  - 이 때 최장 prefix 대응 규칙(가장 긴 prefix와 일치되는것)을 적용시킨다.
  - 입력포트에서 출력포트가 결정되면 스위칭 구조로 패킷을 보낸다.
  - 스위칭 구조에서는 3가지 유형의 교환이 존재한다.
  - (1) 메모리를 통한 교환 : 가장 단순, 라우팅 프로세서가 직접 제어 (2개 이상 패킷 동시 전달 불가능)
  - (2) 버스를 통한 교환 : 제어X, Label을 달아서 모든 출력 포트에 전달하고 일치하는 포트만 받아들임. (작은 지역에서 빠름)
  - (3) 인터커넥션을 통한 교환 : 버스 대역폭 제한을 위해 2N 버스로 구성(크로스바 스위치), 병렬 전달 가능
  - 입력 큐잉 : 앞에 애 때문에 뒤에 있는 애가 못가는 HOL 차단이 발생할 수 있다. (FCFS,First Come First Served)
  - 출력 큐잉 : 회선 전송 속도 보다 스위치 속도가 빠르면 패킷이 출력 큐에 쌓일 수 있다.
  - 큐잉 지연을 줄이기 위해 패킷을 잘 스케쥴링 해야 한다.
  - (1) FIFO(First-In-First-Out) : 도착한 순서와 동일한 순서로 출력 링크에 전송
  - (2) 우선순위 큐잉 : 우선순위 클래스를 나눠서 높은 우선순위부터 끝내기 ( 같으면 FIFO 적용) (ex. VoIP > SMTP)
  - 비선점 우선순위 큐잉의 경우 높은애가 중간에 들어와도 중간에 멈추지 않는다.
  - (3) RR(Round Robin) : 여러 개의 클래스를 나눠서 번갈아가며 패킷을 전송, 링크가 유휴 상태가 되는걸 허용하지 않는다.
  - (4) WFQ(Weighted Fair Queuing) : RR + 가중치(클래스마다 서비스 시간이 다름)

 3) 인터넷 프로토콜(IP) : IPv4 주소지정, IPv6 등
  - IPv4 는 데이터그램의 길이가 16bit라 65535바이트까지 표현이 가능하다.
  - TTL(Time-to-Live) : 생명시간, TTL이 0이되면 라우터가 데이터그램을 폐기한다.
  - 라우터는 데이터그램 체크섬에서 오류가 발견되면 걍 폐지해버린다.
  - TCP/IP 데이터그램은 총 40바이트의 헤더를 전송한다. (IP:20바이트, TCP:20바이트)
  - MTU : 한번에 보낼 수 있는 최대 바이트 양
  - 데이터그램 단편화 : 링크 계층 프레임마다 다른 MTU를 갖기 때문에 데이터그램을 작게 쪼개야 된다.
  - 쪼개진 데이터그램은 종단 시스템에서 단편화 필드를 보고 합친다. (식별자, 플래그, 오프셋)
  - IPv4는 대략 40억개 주소가 사용 가능한데 거의 다 사용함.. 십진 표기법 사용.
  - 서브넷 마스크 : ex. 223.1.1.0/24 일 때, /24는 앞의 24bit가 서브넷 주소를 뜻함. 나머지 8개가 호스트 주소임.
  - 원칙대로 서브넷끼리는 다른 주소를 가지지만, 실제로 같은 주소를 가지는 서브넷들이 많다.
  - CIDR : 인터넷 주소 할당 방식, a.b.c.d/x,  x는 MSB를 의미함. Prefix라 부름
  - Prefix를 구성하면, 외부에서 내부로 들어올 때 Prefix만 고려하면 되므로 포워딩 테이블 크기가 줄어들어서 좋음.
  - 클래스 주소 체계 : A(8), B(16), C(24)가 서브넷 주소인 체계인데 비효율적이라 요즘은 안 쓰임.
  - 브로드캐스트 주소 : 255.255.255.255, 여기에 데이터그램을 보내면 같은 서브넷의 모든 호스트에게 전달 된다.
  - 주소 블록 획득하는 법 : 주소를 제공하는 ISP와 접촉해야함. ISP는 ICANN이라는 최상위 국제기관에게 할당받아야함.
  - 호스트 주소 획득 : 동적 호스트 구성 프로토콜 (DHCP) = 플러그 앤 플레이 프로토콜 = 제로 구성 프로토콜
  - 시스템 관리자가 라우터 안에 IP를 할당하고, 호스트 IP는 네트워크에 접속할 때마다 동일한 임시 IP 주소를 받음.
  - DHCP는 클라이언트/서버 프로토콜로써, 각 서브넷은 DHCP 서버를 가질 수 있다.
  - DHCP 4단계 과정
  - (1) DHCP 서버 발견 : 서버 발견하기 위해서 브로드캐스팅(255.255.255.255)으로 발견 메세지를 보낸다.
  - (2) DHCP 서버 제공 : 서버는 발견메세지를 받고 다시 브로드캐스팅으로 보내고 클라이언트는 최적을 골라서 사용한다.
  - 발견 메세지에는 ID, IP, 주소, 네트워크 마스크, 임대기간이 있다.
  - (3) DHCP 요청 : 클라이언트는 하나를 선택해서 요청 메세지로 응답함
  - (4) DHCP ACK 응답 : 서버는 알겠다고 하고, 이제 클라이언트는 그 IP를 사용할 수 있음
  - DHCP의 문제점 : 서브넷 사이를 이동할 때, DHCP의 서버가 바뀌므로 TCP 연결 불가능
  - NAT(네트워크 주소 변환) : 해당 주소를 이미 할당했거나 다른 관리자들은 어떻게 하는지 알고 싶을때 변환할 수 있다.
  - SOHO : Small Office, Home Office.. 점점 회사가 작아지고 집에서 하기 때문에 LAN이 많이 필요하다.
  - NAT 변환 테이블을 이용해 흔한 IP도 사용 가능
  - NAT traversal problem : 포트 번호가 호스트 식별이 아닌 프로세스 식별에 사용하므로, 홈 네트워크에서 실행되는 서버에 문제가 발생할 수 있다.
  - IPv6 : IPv4가 모두 고갈 되어서 개발함. 32비트를 128비트로 확장하고 헤더를 간소화함.

 4) 일반적인 포워딩 및 소프트웨어 기반 네트워크(SDN)
  - 3계층 기능 : NAT, 방화벽, 부하 균등화기
  - SDN : 3계층 기능의 비용 부담을 줄이기 위해 통합 접근 방식 제공 (MATCH -> ACTION)

5. 네트워크 계층 : 제어 평면

 1) 네트워크 계층 : 제어 평면 개요
  - 포워딩 테이블과 플로우 테이블은 데이터 평면과 제어 평면을 연결하는 요소이다.
  - 두 가지 방법으로 관리 될 수 있다.
  - (1) 라우터별 제어 : 각각 다른 라우터와 통신하여 라우팅 알고리즘을 사용 (OSPF, BGP)
  - (2) 논리적으로 중앙 집중된 제어 : 중앙 컨트롤러가 만들어서 배포함. 라우터에서는 CA라는 제어 에이전트만 놓고 최소한의 기능만 한다. (Google, MS)

 2) 라우팅 알고리즘
  - 링크 상태(LS) 라우팅 알고리즘 : 모든 노드로 자기 상태를 브로드 캐스팅을 한다. (다익스트라 알고리즘)
  - LS의 복잡도는 O(N^2)이지만 우선순위큐를 사용하면 더 좋아짐.
  - LS는 진동 문제가 발생할 수 있다. (부하 때문에 최소 경로가 자꾸 반대로 바뀜)
  - 진동 문제 해결법 : 트래픽 신경X, 알고리즘 시행 시간 랜덤으로 해서 동시 실행 X
  - 거리 벡터(DV) 라우팅 알고리즘 : 벨만-포드 식으로 포워딩 테이블 엔트리 제공. 이웃이 수정되면 그 이웃도 다시 수정되는 방식..
  - DV는 더 이상 갱신 메세지가 없을 때 까지 알고리즘이 반복된다.
  - LS와 DV 비교
  - (1) 메세지 복잡성 : LS는 다 보내야되는데, DV는 이웃만. 즉, DV 승리
  - (2) 수렴 속도 : LS는 느리지만, DV는 '무한계수'문제(?)가 발생할 수 있음. 즉, 무승부
  - (3) 견고성 : 라우터가 고장, 파손, 오작동의 경우 LS는 한부분만 오류, DV는 암처럼 퍼짐;; 즉, LS 승리
  - 두 개 모두 인터넷에서 사용중이고, DV가 더 많이 사용됨.

 3) 인터넷에서의 AS 내부 라우팅 : OSPF
  - ISP는 여러개의 라우터를 AS(자율 시스템)으로 묶어서 자신의 방법으로 관리함.
  - AS 넘버는 ICANN에서 제공하고 같은 AS는 서로에 대한 정보를 가지고 같은 알고리즘을 사용함
  - Intra-AS 라우팅 알고리즘이라고도 부름
  - OSPF(개방형 최단 경로 우선 프로토콜) : LS 알고리즘, 30분마다 링크 상태 갱신, 복잡한 프로토콜이다.

 4) 인터넷 서비스 제공업자(ISP) 간의 라우팅 : BGP(Border Gateway Product)
  - 여러 AS를 거쳐 DV 알고리즘을 돌리는 분산형/비동기식 프로토콜
  - Inter-AS 라우팅 알고리즘이라고도 부름
  - BGP??
  - IP 애니캐스트 : 같은 IP주소를 여러개 서버에 두는 것, BGP를 이용해 똑같은 DNS 서버 주소로 가까운 DNS 서버를 찾음.
  - 라우팅 정책??
  - 인터넷에서 존재 획득 : 주변 ISP에게 자신의 IP 접두부를 BGP로 보내면 계속 전파되어 모든 라우터들이 알게 된다.

