---
title: "C++ 개념 정리"
date: 2019-05-27 22:39:28 -0400
categories: jekyll update
---

# 햇갈리는 C++

1. C 구조체에는 함수X, C++ 구조체에는 함수O
2. 클래스 멤버 기본 속성은 Private이다.
3. 생성자는 반환 형식도 없고 return도 없다.
4. 생성자는 public에 해야된다. (private는 클래스 내부만 가능.)
5. 생성자가 없으면 디폴트 생성자가 있지만, 생성자가 하나라도 있으면 디폴트 생성자는 없다.
6. This 포인터는 본인 객체의 주소를 알려줄 때 쓰이는데, 연산자 오버로딩 말고는 딱히...
7. 클래스 멤버 변수 초기화 하려면 생성자 이용해야함. (걍 = 붙여서 주면 경고먹음)
8. friend변수,  A가 B를 친구라고 설정하면, B에서는 A의 모든 private를 사용할 수 있음.
   근데 여기서 A가 어떤 전역함수를 친구라고 설정하면, 전역함수에서 A의 모든 private 사용할 수 있음.
9. ::는 '범위 지정 연산자' 라고 부름, 전역변수를 가져올 때 사용할 수도 있음.
10. 인라인 함수의 장점 : 매크로 함수의 장점을 그대로 가져오면서, 구현을 용이하게 하고, 컴파일러에게 최적화의 기회를 제공한다.
11. 레퍼런스 제약 2가지 : 상수는 참조 불가능, 선언과 동시에 무조건 초기화.
12. 레퍼런스 장점 : 포인터 연산 없이 함수 외부에 변수 접근이 가능해서 편리하고 안정적이다. 전달 인자를 레퍼런스로 하면 복사 연산이 필요없어서 좋다.
13. c++은 int val(20) 이렇게 변수를 초기화 할 수도 있음.
14. Member Initializer : 생성자(_x,_y) : x(_x), y(_y) 이렇게 초기화 하는거.. (const 변수 초기화할때 사용...)
15. 클래스 복사생성자를 만들려면 클래스이름(const 클래스이름& 이름) 이렇게 해야됨..
16. 복사 생성자는 따로 안만들어도 디폴드가 생기는데 이건 얕은복사라서, 만약 동적할당을 내부에서 했다면
     따로 복사 생성자를 만들어서 깊은복사를 해야 된다.
17. 함수 내에서 객체를 리턴하던, 함수에게 객체를 전달하던 '임시 객체'가 생겼다 사라짐
18. Const Member 함수 : 내부 멤버 변수 못바꿈, 상수 함수 아니면 부르지도 못함, 포인터 반환 불가 ( 함수 뒤에 const 붙임)
19. Static Member : 같은 클래스 객체들이 공유하는 변수. 밖에서 선언을 해줘야함. 안하면 경고
20. Mutable Member : const 함수 안에서 변경이 가능한 변수...
21. 상속의 장점 : 재사용으로 코드 중복 감소, 유지 보수가 쉬움.
22. 파생 클래스는 기본 클래스의 생성자를 명시적으로 호출해야하며, 기본 클래스의 멤버를 초기화 해야한다. (private면 생성자를 호출해서 하던지..)
23. 기본 클래스의 private 멤버는 파생 클래스도 접근 못함.. (함수로 접근..)
24. 객체 포인터는 그 클래스 객체뿐 아니라, 그 클래스의 파생 클래스의 객체 주소도 저장 가능하다.
25. 오버라이딩을 하면 기본 클래스의 멤버를 가리는 효과가 있다. 
26. 가상함수를 정의하면 오버라이딩할 수 있는데, 생략이 가능하고, 마지막 오버라이딩 된 함수가 호출된다. (동적 바인딩임. 런타임중에 실행.)
27. 기본 클래스에서 아무 동작도 하지 않는 가상함수를 선언하면 그것은 추상 클래스라고 한다. (객체화 안함, 인터페이스 역할)
28. 다형성 : 함수 오버로딩, 오버라이딩, 동적 바인딩 등
29. virtual 소멸자 : virtual로 오버라이딩 되는 객체들도 같이 소멸시킴. (ex. virtual ~AAA(){...})
30. 연산자 오버로딩은 멤버함수로도, 전역함수로도 만들 수 있다. operator 키워드를 이용하자. 근데 전역함수는 friend처리를 해줘야된다.
31. 연산자 오버로딩에서 전위증가와 후위증가는 int 키워드를 이용하자. 후위증가에는 int키워드와 const 키워드를 넣어야한다.
32. cout, cin도 오버로딩이 가능, ostream& operator <<(ostream& os, const Point& pos){..} 이렇게.. 전역함수로... friend 넣어주고...
33. 템플릿 함수,클래스의 특수화 : template<>이렇게 하고 해당 자료형 함수 만들면 그 자료형만 따로 취급함.
34. 템플릿 매개변수도 디폴트 자료형과 값이 지정 가능하다. (ex. template<typename T=int, int len=7>)
35. 예외 경우 : 메모리 부족, 잘못 입력, 파일 존재X..
36. 함수 내에서 예외 처리가 될 경우, 바로 스택풀기(Stack Unwinding)가 들어가면서 try영역이 있는 함수까지 내려온다. (끝까지 없으면 abort 함수에 의해 프로그램 종료됨)
37. catch(bad_alloc ex){..} 을 이용해서 메모리 부족 예외 처리 가능, catch(...){}은 모든 예외 다 처리

